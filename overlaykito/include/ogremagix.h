/*
-----------------------------------------------------------------------------
Filename:    ogremagix.h
-----------------------------------------------------------------------------

This source file is generated by the Ogre AppWizard.

Check out: http://conglomerate.berlios.de/wiki/doku.php?id=ogrewizards

Based on the Example Framework for OGRE
(Object-oriented Graphics Rendering Engine)

Copyright (c) 2000-2007 The OGRE Team
For the latest info, see http://www.ogre3d.org/

You may use this sample code for anything you like, it is not covered by the
LGPL like the rest of the OGRE engine.
-----------------------------------------------------------------------------
*/
#ifndef __ogremagix_h_
#define __ogremagix_h_

#include "MagixApplication.h"
#include "GlowMaterialListener.h"
#include "VolumetricSunLightFrameListener.h"

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#include "../res/resource.h"
#endif


class ogremagixFrameListener : public MagixFrameListener, public OIS::MouseListener, public OIS::KeyListener
{
protected:
   SceneManager* mSceneMgr;
   MagixHandler *mMagixHandler;
public:
      ogremagixFrameListener(MagixHandler *magixHandler, SceneManager *sceneMgr, RenderWindow* win, Camera* cam)
         : MagixFrameListener(magixHandler, win, cam, true, true),
         mSceneMgr(sceneMgr),
		 mMagixHandler(magixHandler)
	{
		mMouse->setEventCallback(this);
        mKeyboard->setEventCallback(this);
		mKeyboard->setTextTranslation(OIS::Keyboard::Unicode);
	}

	bool frameStarted(const FrameEvent& evt)
	{
		bool contFlag = MagixFrameListener::frameStarted(evt);

		if(contFlag)
		{
			contFlag = mMagixHandler->update(evt);
			if(mWindow->getViewport(0)->getBackgroundColour()!=mSceneMgr->getFogColour())mWindow->getViewport(0)->setBackgroundColour(mSceneMgr->getFogColour());
		}
		//if(!contFlag)mMagixHandler->shutdown();

      return contFlag;

	}

	// MouseListener
    bool mouseMoved(const OIS::MouseEvent &e)
	{
		using namespace OIS;

		const MouseState &ms = e.state;
		const Real mouseSense = (Real)(0.5 + mMagixHandler->getMagixGUI()->getMouseSensitivity());
		mMagixHandler->getMagixGUI()->showMouse(true);
		if(mMagixHandler->getMagixGUI()->getUseWindowsCursor())
		{
			//if(ShowCursor(true)>0)ShowCursor(false);
			unsigned int tW,tH,tCD;
			int tL,tT;
			tagPOINT lpPoint;
			mWindow->getMetrics(tW,tH,tCD,tL,tT);
			GetCursorPos(&lpPoint);
			const int tX = lpPoint.x-tL-4;
			const int tY = lpPoint.y-tT-30;
			mMagixHandler->getMagixGUI()->scrollMouse(tX,tY,tW,tH,true);
			if(tX<0 || tY<0 || tX>0&&(unsigned)tX>tW || tY>0&&(unsigned)tY>tH){
				if(ShowCursor(true)>0)
					ShowCursor(false);
			}
			else if(ShowCursor(false)<-1)
				ShowCursor(true);
		}
		else
		{
			if(mMagixHandler->getMagixGUI()->isTablet())
			{
				//tablet cursor always moves, see HERE
			}
			else
			{
				mMagixHandler->getMagixGUI()->scrollMouse((int)(ms.X.rel * 1 * mouseSense), (int)(ms.Y.rel * 1 * mouseSense), (int)mWindow->getWidth(), (int)mWindow->getHeight());
			}
		}

		return true;
	}
    bool mousePressed(const OIS::MouseEvent &e, OIS::MouseButtonID id)
	{
		using namespace OIS;

		mMagixHandler->getMagixGUI()->setLeftClick(e.state.buttonDown( MB_Left ));
		mMagixHandler->getMagixGUI()->setRightClick(e.state.buttonDown( MB_Right ));
		return true;
	}
    bool mouseReleased(const OIS::MouseEvent &e, OIS::MouseButtonID id)
	{
		using namespace OIS;

		mMagixHandler->getMagixGUI()->setLeftClick(e.state.buttonDown( MB_Left ));
		mMagixHandler->getMagixGUI()->setRightClick(e.state.buttonDown( MB_Right ));
		return true;
	}

    // KeyListener
    bool keyPressed(const OIS::KeyEvent &e)
	{
		using namespace OIS;


		
		//Outgame controls
		{
			switch (e.key)
			{
				case KC_ESCAPE: mMagixHandler->getMagixGUI()->toggleShowOptions(); break;
				//case KC_L: showDebugOverlay(!isStatsOn); break;
				case KC_SYSRQ:
					mWindow->writeContentsToTimestampedFile("../screenshot",".PNG");
					break;

				default:
				break;
			}
		}

		//mMagixHandler->getMagixGUI()->getAlertBox()->showAlert(StringConverter::toString(e.key),0.5,0.5);

		return mContinue;
	}
    bool keyReleased(const OIS::KeyEvent &e)
	{
		using namespace OIS;


		return true;
	}

};



class ogremagixApp : public MagixApplication
{
private:
	MagixHandler *mMagixHandler;
	Viewport * pViewPort;
	VolumetricSunLightFrameListener * pEffectListener;

	public:
		ogremagixApp():
		  MagixApplication(mMagixHandler)
    {
		mMagixHandler = new MagixHandler();
	}

	~ogremagixApp()
	{
		Ogre::OverlayManager *overlayManager = Ogre::OverlayManager::getSingletonPtr();
		overlayManager->destroyAll();
		delete mMagixHandler;
	}

protected:

	virtual void createCamera(void)
	{
      // Create the camera
      mCamera = mSceneMgr->createCamera("PlayerCam");
      mCamera->setNearClipDistance( 0.1 );
      mCamera->setFarClipDistance( 30000 );
	}


    virtual bool configure(void)
    {
        // Show the configuration dialog and initialise the system
        // You can skip this and use root.restoreConfig() to load configuration
        // settings if you were sure there are valid ones saved in ogre.cfg
		if(mRoot->restoreConfig())
//		if(mRoot->showConfigDialog())
        {
            // If returned true, user clicked OK so initialise
            // Here we choose to let the system create a default rendering window by passing 'true'
            mWindow = mRoot->initialise(true,"Magix");
			mWindow->setDeactivateOnFocusChange(false);
			// Let's add a nice window icon
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
			HWND hwnd;
			mWindow->getCustomAttribute("WINDOW", (void*)&hwnd);
			LONG iconID   = (LONG)LoadIcon( GetModuleHandle(0), MAKEINTRESOURCE(IDI_APPICON) );
			SetClassLong( hwnd, GCL_HICON, iconID );
#endif
            return true;
        }
        else
        {
            return false;
        }
    }


	// Just override the mandatory create scene method
	virtual void createScene(void)
	{
		ColourValue fadeColour = ColourValue(192.0f/255, 229.0f/255, 253.0f/255);
//kito		mSceneMgr->setFog( FOG_LINEAR, fadeColour, .0001, 500, 1500);
		mWindow->getViewport(0)->setBackgroundColour(fadeColour);

		mMagixHandler->initialize(mSceneMgr,mWindow);

		// Infinite far plane?
			mCamera->setFarClipDistance(0);
		

	}

	virtual void destroyScene()
	{
		mMagixHandler->shutdown();
	}

   // Create new frame listener
	void createFrameListener(void)
	{
		mFrameListener= new ogremagixFrameListener(mMagixHandler, mSceneMgr, mWindow, mCamera);
		mRoot->addFrameListener(mFrameListener);
	}
};

#endif // #ifndef __ogremagix_h_